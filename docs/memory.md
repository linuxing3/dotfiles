# 内存管理

## 内存

### 一般分配 4K 的内存区域

> 2 ^ 12 = 1024 x 4 = 4096 = 4K

### 内存寻址范围

> 页目录 1024 x 页表 1024 x 物理内存页 4K = 4GB

对应线性地址

> [10bit 页目录 0000000000 - 10 比特页表 0000000000 - 12 比特偏移值 000000000000]

1. 页目录的物理地址 ---> 页寄存器

2. 页表的物理地址 ---> 内存物理地址中

因为物理内存页大小为 4K, 因此内存页一定是 4 的整数倍, 12 位一定是 0

12位空闲空间,可以用于标记[读/写/映射]信息, 其中最后 1 位标记是否[已经映射]

3. TLB 缓存 (Translation Lookable Buffer) 保存已经转换过的映射关系

4. 切换进程会清空 TLB 并重新映射

### 映射方法

> 回忆小甲鱼的教程中:
> 线性地址在 8 位处理器是[8 位段地址:8 位偏移地址], 共 16 位
> 因为地址总线是 20 位的关系,要进行转化(通过`MMU`和`ALU`计算)
> 如线性地址为 [00 40 10 00], 栈地址为 [00 40], 偏移地址为 [10 00]
> 偏移地址[10 00], 向左移 1 位,相当于乘以 16, 得到物理地址 [01 00 00]

### 进程`Process`和线程`Thread`

加载一个exe 可执行文件,就相当于一个进程 Process,有自己[虚拟地址空间]

加载一个[函数]或[功能],就相当于运行一个线程 Thread, 线程是操作系统调度执行的基本单位(使用栈基 ebp/栈指针 esp/指令指针 ip 来顺序运行)

### 虚拟地址空间

1. 内核空间(系统保留)

`task_struct` 共享空间

> 进程控制信息 PCB: 页目录/Id/父进程 Id/状态/打开文件的句柄表/ TCB 列表

> 内核栈

2. 用户空间(用户使用)

`task_struct` 共享空间

> 线程控制信息 TCB:

> 进程执行体: 代码段/线程栈空间

#### 系统调用

CPU 中断控制器: 保存线程 -> 调用中断 -> 恢复现场

系统通过指定调用`中断`,切换到`内核空间`,调用系统功能

- 中断向量表 { 编号:处理程序 }, 如`0x80`代表`系统调用派发`

- 系统调用表 { 系统调用编号: 函数入口地址 }

- `syscall`在寄存器`IR`中查询`系统调用编号`

### 多线程的触发

#### CPU 时间片触发

1. 一个线程执行

2. `时钟中断`

3. 再找一个线程执行

#### 多线程并行/并发

1. 同步的本质 = 临界区操作的互斥

- 临界区 Edge Area (操作同一内存区域数据的不同指令)

- 原子指令`compare & swap` / `fetch & add` / `test & set`

2. 互斥 `Mutex`的方式 = 在原子指令前`lock`总线

> 单核: CPU 具有内存空间地址, 锁总线
> 多核: 每个核有自己的内存空间地址, MESI 协议

### 进程间同步

> _生产者_ -> (?) *缓冲区* (?) -> _消费者_

#### 计数器 `count`

计数器 = 0, 可生产,不消费

计数器 > 0, 可消费,不生产

生产者-消费者问题 = 产能过剩


#### 信号量(标识符) `semaphone` 

功能是同一时间只让一个进程读写

```c++
int empty = 7
int full = 0
int mutext = 1

producer() {
  int item = produce_item()
  down(&empty)
  down(&empty)
  insert_item(item)
  up(&mutext)
  up(&full)
}

consumer() {
  down(&full)
  down(&mutext)
  int item = remove_item()
  up(&mutext)
  up(&empty)
  consume_item(item)
}
```
